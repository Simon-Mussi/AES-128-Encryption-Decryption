$date
	Thu Sep 19 08:33:50 2024
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module Testbench $end
$var wire 1 ! Cout $end
$var wire 4 " Sum [3:0] $end
$var wire 8 # Product [7:0] $end
$var wire 4 $ Diff [3:0] $end
$var reg 4 % A [3:0] $end
$var reg 4 & B [3:0] $end
$var reg 1 ' Cin $end
$scope module adder $end
$var wire 4 ( A [3:0] $end
$var wire 4 ) B [3:0] $end
$var wire 1 ' Cin $end
$var wire 1 ! Cout $end
$var wire 4 * Sum [3:0] $end
$var wire 1 + C3 $end
$var wire 1 , C2 $end
$var wire 1 - C1 $end
$scope module FA0 $end
$var wire 1 . a $end
$var wire 1 / b $end
$var wire 1 ' cin $end
$var wire 1 - cout $end
$var wire 1 0 sum $end
$upscope $end
$scope module FA1 $end
$var wire 1 1 a $end
$var wire 1 2 b $end
$var wire 1 - cin $end
$var wire 1 , cout $end
$var wire 1 3 sum $end
$upscope $end
$scope module FA2 $end
$var wire 1 4 a $end
$var wire 1 5 b $end
$var wire 1 , cin $end
$var wire 1 + cout $end
$var wire 1 6 sum $end
$upscope $end
$scope module FA3 $end
$var wire 1 7 a $end
$var wire 1 8 b $end
$var wire 1 + cin $end
$var wire 1 ! cout $end
$var wire 1 9 sum $end
$upscope $end
$upscope $end
$scope module multiplier $end
$var wire 4 : A [3:0] $end
$var wire 4 ; B [3:0] $end
$var wire 8 < Product [7:0] $end
$var wire 8 = P [7:0] $end
$upscope $end
$scope module subtractor $end
$var wire 4 > A [3:0] $end
$var wire 4 ? B [3:0] $end
$var wire 1 ! Cout $end
$var wire 4 @ Diff [3:0] $end
$var wire 4 A B_neg [3:0] $end
$scope module RCA $end
$var wire 4 B A [3:0] $end
$var wire 4 C B [3:0] $end
$var wire 1 D Cin $end
$var wire 1 ! Cout $end
$var wire 4 E Sum [3:0] $end
$var wire 1 F C3 $end
$var wire 1 G C2 $end
$var wire 1 H C1 $end
$scope module FA0 $end
$var wire 1 I a $end
$var wire 1 J b $end
$var wire 1 D cin $end
$var wire 1 H cout $end
$var wire 1 K sum $end
$upscope $end
$scope module FA1 $end
$var wire 1 L a $end
$var wire 1 M b $end
$var wire 1 H cin $end
$var wire 1 G cout $end
$var wire 1 N sum $end
$upscope $end
$scope module FA2 $end
$var wire 1 O a $end
$var wire 1 P b $end
$var wire 1 G cin $end
$var wire 1 F cout $end
$var wire 1 Q sum $end
$upscope $end
$scope module FA3 $end
$var wire 1 R a $end
$var wire 1 S b $end
$var wire 1 F cin $end
$var wire 1 ! cout $end
$var wire 1 T sum $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
0T
1S
1R
1Q
0P
0O
0N
1M
1L
1K
1J
0I
0H
1G
0F
b101 E
0D
b1011 C
b1010 B
b1011 A
b101 @
b101 ?
b1010 >
b110010 =
b110010 <
b101 ;
b1010 :
19
08
17
16
15
04
13
02
11
10
1/
0.
0-
0,
0+
b1111 *
b101 )
b1010 (
0'
b101 &
b1010 %
b101 $
b110010 #
b1111 "
x!
$end
#10
1!
09
1+
06
1T
1,
1F
03
0K
1H
1N
0G
b1010 $
b1010 @
b1010 E
0Q
1-
0M
1P
b1 "
b1 *
10
12
05
b1101 A
b1101 C
1.
01
14
1I
0L
1O
1'
b11 &
b11 )
b11 ;
b11 ?
b100111 #
b100111 <
b100111 =
b1101 %
b1101 (
b1101 :
b1101 >
b1101 B
#20
1Q
1G
b1110 $
b1110 @
b1110 E
1N
1M
b0 "
b0 *
00
02
b1111 A
b1111 C
11
1L
0'
b1 &
b1 )
b1 ;
b1 ?
b1111 #
b1111 <
b1111 =
b1111 %
b1111 (
b1111 :
b1111 >
b1111 B
#30
0N
0!
19
1K
0H
0+
13
16
0Q
b1001 $
b1001 @
b1001 E
1T
0J
0S
b1110 "
b1110 *
00
0/
12
18
b110 A
b110 C
04
07
0O
0R
1'
b1010 &
b1010 )
b1010 ;
b1010 ?
b11110 #
b11110 <
b11110 =
b11 %
b11 (
b11 :
b11 >
b11 B
#40
0!
19
0+
0,
16
1K
b1101 $
b1101 @
b1101 E
1Q
0-
1J
b1111 "
b1111 *
10
1/
02
b111 A
b111 C
0.
14
0I
1O
0'
b1001 &
b1001 )
b1001 ;
b1001 ?
b110110 #
b110110 <
b110110 =
b110 %
b110 (
b110 :
b110 >
b110 B
#60
